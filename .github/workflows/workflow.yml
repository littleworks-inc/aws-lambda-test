name: Deploy Lambda Function
on:
  workflow_dispatch:
    inputs:
      api_category:
        description: "API category (dashboard_api, risk_alert_api, etc.)"
        required: true
        type: choice
        options:
          - dashboard_api
          - risk_alert_api
          - intelligence_api
          - regulations_api
          - evidence_api
      function_name:
        description: "Lambda function name (e.g., get_risk_score)"
        required: true
        type: string
      environment:
        description: "Target environment (stage, prod)"
        required: true
        type: choice
        options:
          - stage
          - prod

env:
  AWS_REGION: ca-central-1
  # AWS_ROLE_TO_ASSUME: arn:aws:iam::125655559748:role/service-role/get_risk_score-role-86ng99js
  PROJECT_ROOT: NetraScale_API
  
permissions:
  id-token: write
  contents: read
  
jobs:
  deploy:
    name: Deploy Lambda to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.13'

    - name: Set function path and name
      id: set_function_info
      run: |
        # Construct full function path
        FUNCTION_PATH="${{ env.PROJECT_ROOT }}/${{ inputs.api_category }}/lambdas/${{ inputs.function_name }}"
        echo "FUNCTION_PATH=$FUNCTION_PATH" >> $GITHUB_ENV
        
        # Set Lambda function name - using the folder name as the function name
        echo "LAMBDA_FUNCTION_NAME=${{ inputs.function_name }}" >> $GITHUB_ENV
        echo "Function name: ${{ inputs.function_name }}"
        echo "Function path: $FUNCTION_PATH"
        
        # Check if the function directory exists
        if [ ! -d "$FUNCTION_PATH" ]; then
          echo "Error: Function directory not found at $FUNCTION_PATH"
          exit 1
        fi
        
        # Determine the main handler file - prioritize app.py
        if [ -f "$FUNCTION_PATH/app.py" ]; then
          echo "Using app.py as handler file"
          echo "HANDLER_FILE=app.py" >> $GITHUB_ENV
          echo "HANDLER_NAME=lambda_handler" >> $GITHUB_ENV
        else
          # Look for any Python file with lambda_handler function as fallback
          HANDLER_FOUND=false
          for PY_FILE in $(find "$FUNCTION_PATH" -name "*.py" -not -name "__init__.py"); do
            FILENAME=$(basename "$PY_FILE")
            if grep -q "def lambda_handler" "$PY_FILE"; then
              echo "Using $FILENAME as handler file"
              echo "HANDLER_FILE=$FILENAME" >> $GITHUB_ENV
              echo "HANDLER_NAME=lambda_handler" >> $GITHUB_ENV
              HANDLER_FOUND=true
              break
            fi
          done
          
          if [ "$HANDLER_FOUND" != "true" ]; then
            echo "No handler file found in $FUNCTION_PATH"
            echo "Available Python files:"
            find "$FUNCTION_PATH" -name "*.py" -not -name "__init__.py"
            exit 1
          fi
        fi

    - name: Install dependencies
      run: |
        pip install awscli pytest jq
        echo "Role: ${{ vars.AWS_ROLE_TO_ASSUME }}"
        echo "Function path: ${{ inputs.function_name }}_Role"
        echo "AWS_ROLE_TO_ASSUME=${{ vars[inputs.function_name] }}"

    # - name: Configure AWS credentials
    #   uses: aws-actions/configure-aws-credentials@v3
    #   with:
    #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
    #     aws-region: ${{ env.AWS_REGION }}
    #     #role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
       
    - name: Prepare function package
      run: |
        cd ${{ env.FUNCTION_PATH }}
        
        # Create a temporary directory for packaging
        mkdir -p /tmp/lambda-package
        
        # Copy all files to the package directory (including config.json, requirements.txt, etc.)
        cp -r * /tmp/lambda-package/
        
        # Create zip file
        cd /tmp/lambda-package
        zip -r /tmp/function.zip .

    - name: Load Environment Variables
      run: |
        echo "Loading environment variables for ${{ inputs.environment }}"
        
        # Determine API category from the function path
        API_CATEGORY="${{ inputs.api_category }}"
        API_ENV_VARS_DIR="${{ env.PROJECT_ROOT }}/$API_CATEGORY/env-vars"
        FUNCTION_ENV_VARS_DIR="${{ env.FUNCTION_PATH }}/env-vars"
        
        # First check for function-specific env-vars, then API-level env-vars, then config.json
        if [ -d "$FUNCTION_ENV_VARS_DIR" ] && [ -f "$FUNCTION_ENV_VARS_DIR/${{ inputs.environment }}.json" ]; then
          echo "Using function-specific environment variables"
          cp "$FUNCTION_ENV_VARS_DIR/${{ inputs.environment }}.json" /tmp/env-vars.json
        elif [ -d "$API_ENV_VARS_DIR" ] && [ -f "$API_ENV_VARS_DIR/${{ inputs.environment }}.json" ]; then
          echo "Using API-level environment variables for $API_CATEGORY"
          cp "$API_ENV_VARS_DIR/${{ inputs.environment }}.json" /tmp/env-vars.json
        elif [ -f "${{ env.FUNCTION_PATH }}/config.json" ]; then
          echo "Using config.json as environment variables"
          cp "${{ env.FUNCTION_PATH }}/config.json" /tmp/env-vars.json
        else
          echo "No environment variables found, using empty config"
          echo "{}" > /tmp/env-vars.json
        fi
        
        # Replace sensitive values if needed
        if [ "${{ inputs.environment }}" == "prod" ]; then
          # Add any prod-specific variable replacements here
          if grep -q "DB_PASSWORD" /tmp/env-vars.json; then
            sed -i 's/"DB_PASSWORD": *"[^"]*"/"DB_PASSWORD": "${{ secrets.PROD_DB_PASSWORD }}"/' /tmp/env-vars.json
          fi
          
          # Add more prod secrets as needed
          # if grep -q "API_KEY" /tmp/env-vars.json; then
          #   sed -i 's/"API_KEY": *"[^"]*"/"API_KEY": "${{ secrets.PROD_API_KEY }}"/' /tmp/env-vars.json
          # fi
          
          echo "Applied prod environment variables"
        elif [ "${{ inputs.environment }}" == "stage" ]; then
          # Add any stage-specific variable replacements here
          if grep -q "DB_PASSWORD" /tmp/env-vars.json; then
            sed -i 's/"DB_PASSWORD": *"[^"]*"/"DB_PASSWORD": "${{ secrets.STAGE_DB_PASSWORD }}"/' /tmp/env-vars.json
          fi
          
          # Add more stage secrets as needed
          # if grep -q "API_KEY" /tmp/env-vars.json; then
          #   sed -i 's/"API_KEY": *"[^"]*"/"API_KEY": "${{ secrets.STAGE_API_KEY }}"/' /tmp/env-vars.json
          # fi
          
          echo "Applied stage environment variables"
        fi
        
        # Format for AWS Lambda environment variables
        jq -c '{"Variables": .}' /tmp/env-vars.json > /tmp/config.json
      
    - name: Set IAM Role from GitHub Variables
      run: |
          # Get function name
          FUNCTION_NAME="${{ inputs.function_name }}"
          echo "Looking for IAM role for: $FUNCTION_NAME"
          
          # Use conditional expressions to check each possible function name
          # This is a workaround since GitHub Actions doesn't support dynamic variable references
          
          if [ "$FUNCTION_NAME" == "get_actionable_insights" ]; then
            ROLE="${{ vars.get_actionable_insights }}"
          elif [ "$FUNCTION_NAME" == "get_financial_risks" ]; then
            ROLE="${{ vars.get_financial_risks }}"
          elif [ "$FUNCTION_NAME" == "get_news_feed" ]; then
            ROLE="${{ vars.get_news_feed }}"
          elif [ "$FUNCTION_NAME" == "get_overall_risk_score" ]; then
            ROLE="${{ vars.get_overall_risk_score }}"
          elif [ "$FUNCTION_NAME" == "get_potential_exploits" ]; then
            ROLE="${{ vars.get_potential_exploits }}"
          elif [ "$FUNCTION_NAME" == "get_risk_score_trend" ]; then
            ROLE="${{ vars.get_risk_score_trend }}"
          elif [ "$FUNCTION_NAME" == "get_risk_severity_summary" ]; then
            ROLE="${{ vars.get_risk_severity_summary }}"
          elif [ "$FUNCTION_NAME" == "collect_evidence" ]; then
            ROLE="${{ vars.collect_evidence }}"
          elif [ "$FUNCTION_NAME" == "get_attack_analysis" ]; then
            ROLE="${{ vars.get_attack_analysis }}"
          elif [ "$FUNCTION_NAME" == "get_attack_catalog" ]; then
            ROLE="${{ vars.get_attack_catalog }}"
          elif [ "$FUNCTION_NAME" == "get_common_threat_summary" ]; then
            ROLE="${{ vars.get_common_threat_summary }}"
          elif [ "$FUNCTION_NAME" == "get_sample_incident" ]; then
            ROLE="${{ vars.get_sample_incident }}"
          elif [ "$FUNCTION_NAME" == "get_regulation_information" ]; then
            ROLE="${{ vars.get_regulation_information }}"
          elif [ "$FUNCTION_NAME" == "get_regulation_stats" ]; then
            ROLE="${{ vars.get_regulation_stats }}"
          elif [ "$FUNCTION_NAME" == "get_historical_risk_score" ]; then
            ROLE="${{ vars.get_historical_risk_score }}"
          elif [ "$FUNCTION_NAME" == "get_match_score" ]; then
            ROLE="${{ vars.get_match_score }}"
          elif [ "$FUNCTION_NAME" == "get_mitigation_actions" ]; then
            ROLE="${{ vars.get_mitigation_actions }}"
          elif [ "$FUNCTION_NAME" == "get_regulatory_assessment" ]; then
            ROLE="${{ vars.get_regulatory_assessment }}"
          elif [ "$FUNCTION_NAME" == "get_risk_factor_breakdown" ]; then
            ROLE="${{ vars.get_risk_factor_breakdown }}"
          elif [ "$FUNCTION_NAME" == "get_risk_score" ]; then
            ROLE="${{ vars.get_risk_score }}"
          elif [ "$FUNCTION_NAME" == "get_threat_attacks" ]; then
            ROLE="${{ vars.get_threat_attacks }}"
          elif [ "$FUNCTION_NAME" == "update_mitigation_actions_status" ]; then
            ROLE="${{ vars.update_mitigation_actions_status }}"
          else
            echo "ERROR: No condition found for function $FUNCTION_NAME"
            echo "Please update the workflow to include this function name"
            exit 1
          fi
          
          # Check if we got a role
          if [ -z "$ROLE" ]; then
            echo "ERROR: No IAM role found in GitHub Variables for function $FUNCTION_NAME"
            echo "Please create a repository/environment variable named '$FUNCTION_NAME' with the IAM role ARN"
            exit 1
          fi
          
          echo "Found IAM role for $FUNCTION_NAME"
          echo "AWS_ROLE_TO_ASSUME=$ROLE" 

    # - name: Check if Lambda function exists
    #   id: check_lambda
    #   run: |
    #     if aws lambda get-function --function-name ${{ env.LAMBDA_FUNCTION_NAME }} 2>/dev/null; then
    #       echo "lambda_exists=true" >> $GITHUB_OUTPUT
    #     else
    #       echo "lambda_exists=false" >> $GITHUB_OUTPUT
    #     fi

    # - name: Create or Update Lambda function
    #   run: |
    #     if [ "${{ steps.check_lambda.outputs.lambda_exists }}" == "false" ]; then
    #       echo "Creating Lambda function..."
    #       aws lambda create-function --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
    #         --runtime python3.13 --role ${{ env.AWS_ROLE_TO_ASSUME }} \
    #         --handler ${{ env.HANDLER_FILE }}.${{ env.HANDLER_NAME }} --zip-file fileb:///tmp/function.zip \
    #         --environment "Variables=$(cat /tmp/config.json)"

    #       # Add permission for API Gateway to invoke the Lambda function if needed
    #       STAGE_NAME=""
    #       if [ "${{ inputs.environment }}" == "stage" ]; then
    #         STAGE_NAME="v2"
    #       elif [ "${{ inputs.environment }}" == "prod" ]; then
    #         STAGE_NAME="v1"
    #       else
    #         STAGE_NAME="${{ inputs.environment }}"
    #       fi
          
    #       aws lambda add-permission \
    #         --function-name "${{ env.LAMBDA_FUNCTION_NAME }}" \
    #         --statement-id "AllowAPIGatewayInvoke" \
    #         --action "lambda:InvokeFunction" \
    #         --principal "apigateway.amazonaws.com" \
    #         --source-arn "arn:aws:execute-api:ca-central-1:125655559748:h8kq61julj/${STAGE_NAME}"
    #     else
    #       echo "Updating Lambda function code..."
    #       aws lambda update-function-code \
    #         --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
    #         --zip-file fileb:///tmp/function.zip --publish

    #       echo "Waiting for 10 seconds to allow AWS Lambda to process the code update..."
    #       sleep 10

    #       echo "Updating Lambda function configuration..."
    #       aws lambda update-function-configuration \
    #         --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
    #         --environment "Variables=$(cat /tmp/config.json)"
    #     fi

    - name: Clean up
      run: |
        rm -f /tmp/function.zip
        rm -f /tmp/config.json