name: Deploy All Lambda Functions
on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment (stage, prod)"
        required: true
        type: choice
        options:
          - stage
          - prod
      api_category:
        description: "API category to deploy (all, dashboard_api, risk_alert_api, etc.)"
        required: true
        type: choice
        options:
          - all
          - dashboard_api
          - risk_alert_api
          - intelligence_api
          - regulations_api
          - evidence_api

env:
  AWS_REGION: ca-central-1
  AWS_ROLE_TO_ASSUME: arn:aws:iam::125655559748:role/service-role/get_risk_score-role-86ng99js
  PROJECT_ROOT: NetraScale_API
  
permissions:
  id-token: write
  contents: read
  
jobs:
  find_functions:
    name: Find Lambda Functions
    runs-on: ubuntu-latest
    outputs:
      function_paths: ${{ steps.set-paths.outputs.function_paths }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Install jq
      run: |
        sudo apt-get update
        sudo apt-get install -y jq
        
    - name: Find Lambda Functions
      id: set-paths
      run: |
        if [ "${{ inputs.api_category }}" == "all" ]; then
          # Find all Lambda functions with app.py or lambda_function.py
          FUNCTIONS=$(find ${PROJECT_ROOT} -type d -path "*/lambdas/*" -not -path "*/\.*" | sort)
        else
          # Find Lambda functions in the specific API category
          FUNCTIONS=$(find ${PROJECT_ROOT}/${{ inputs.api_category }} -type d -path "*/lambdas/*" -not -path "*/\.*" | sort)
        fi
        
        # Convert to JSON array for matrix
        FUNCTIONS_JSON=$(echo "$FUNCTIONS" | jq -R . | jq -s .)
        echo "function_paths=$FUNCTIONS_JSON" >> $GITHUB_OUTPUT
        echo "Found functions: $FUNCTIONS_JSON"

  deploy:
    name: Deploy Lambda Functions
    needs: find_functions
    runs-on: ubuntu-latest
    strategy:
      matrix:
        function_path: ${{ fromJson(needs.find_functions.outputs.function_paths) }}
      fail-fast: false
    
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.13'

    - name: Extract function name
      id: extract_function_name
      run: |
        # Extract the directory name as the function name
        FUNCTION_PATH="${{ matrix.function_path }}"
        echo "FUNCTION_PATH=$FUNCTION_PATH" >> $GITHUB_ENV
        
        # Get the function name from the basename of the path
        FUNCTION_NAME=$(basename "$FUNCTION_PATH")
        echo "LAMBDA_FUNCTION_NAME=$FUNCTION_NAME" >> $GITHUB_ENV
        echo "Function name: $FUNCTION_NAME"
        echo "Function path: $FUNCTION_PATH"
        
        # Determine the main handler file
        if [ -f "$FUNCTION_PATH/lambda_function.py" ]; then
          echo "HANDLER_FILE=lambda_function.py" >> $GITHUB_ENV
          echo "HANDLER_NAME=lambda_handler" >> $GITHUB_ENV
        elif [ -f "$FUNCTION_PATH/app.py" ]; then
          echo "HANDLER_FILE=app.py" >> $GITHUB_ENV
          echo "HANDLER_NAME=lambda_handler" >> $GITHUB_ENV
        else
          echo "No supported handler file found in $FUNCTION_PATH"
          exit 1
        fi

    - name: Install dependencies
      run: |
        pip install awscli pytest jq
        
        # Install function-specific dependencies if requirements.txt exists
        if [ -f "${{ env.FUNCTION_PATH }}/requirements.txt" ]; then
          pip install -r ${{ env.FUNCTION_PATH }}/requirements.txt -t ${{ env.FUNCTION_PATH }}/
        fi

    # - name: Configure AWS credentials
    #   uses: aws-actions/configure-aws-credentials@v3
    #   with:
    #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
    #     aws-region: ${{ env.AWS_REGION }}
    #     #role-to-assume: ${{ env.AWS_ROLE_TO_ASSUME }}
       
    - name: Prepare function package
      run: |
        cd ${{ env.FUNCTION_PATH }}
        
        # Create a temporary directory for packaging
        mkdir -p /tmp/lambda-package
        
        # Copy all files to the package directory
        cp -r * /tmp/lambda-package/
        
        # Create zip file
        cd /tmp/lambda-package
        zip -r /tmp/function.zip .

    - name: Load Environment Variables
      run: |
        echo "Loading environment variables for ${{ inputs.environment }}"
        # First check if we have a dedicated env-vars directory at project level
        ENV_VARS_DIR="${{ env.PROJECT_ROOT }}/env-vars"
        LAMBDA_ENV_VARS_DIR="${{ env.FUNCTION_PATH }}/env-vars"
        
        # Use function-specific env-vars if available, otherwise use project-level env-vars
        if [ -d "$LAMBDA_ENV_VARS_DIR" ] && [ -f "$LAMBDA_ENV_VARS_DIR/${{ inputs.environment }}.json" ]; then
          echo "Using function-specific environment variables"
          cp "$LAMBDA_ENV_VARS_DIR/${{ inputs.environment }}.json" /tmp/env-vars.json
        elif [ -d "$ENV_VARS_DIR" ] && [ -f "$ENV_VARS_DIR/${{ inputs.environment }}.json" ]; then
          echo "Using project-level environment variables"
          cp "$ENV_VARS_DIR/${{ inputs.environment }}.json" /tmp/env-vars.json
        elif [ -f "${{ env.FUNCTION_PATH }}/config.json" ]; then
          echo "Using config.json as environment variables"
          cp "${{ env.FUNCTION_PATH }}/config.json" /tmp/env-vars.json
        else
          echo "No environment variables found, using empty config"
          echo "{}" > /tmp/env-vars.json
        fi
        
        # Replace sensitive values if needed
        if [ "${{ inputs.environment }}" == "prod" ]; then
          # Add any prod-specific variable replacements here
          if grep -q "DB_PASSWORD" /tmp/env-vars.json; then
            sed -i 's/"DB_PASSWORD": *"[^"]*"/"DB_PASSWORD": "${{ secrets.PROD_DB_PASSWORD }}"/' /tmp/env-vars.json
          fi
          
          # Add more prod secrets as needed
          # if grep -q "API_KEY" /tmp/env-vars.json; then
          #   sed -i 's/"API_KEY": *"[^"]*"/"API_KEY": "${{ secrets.PROD_API_KEY }}"/' /tmp/env-vars.json
          # fi
          
          echo "Applied prod environment variables"
        elif [ "${{ inputs.environment }}" == "stage" ]; then
          # Add any stage-specific variable replacements here
          if grep -q "DB_PASSWORD" /tmp/env-vars.json; then
            sed -i 's/"DB_PASSWORD": *"[^"]*"/"DB_PASSWORD": "${{ secrets.STAGE_DB_PASSWORD }}"/' /tmp/env-vars.json
          fi
          
          # Add more stage secrets as needed
          # if grep -q "API_KEY" /tmp/env-vars.json; then
          #   sed -i 's/"API_KEY": *"[^"]*"/"API_KEY": "${{ secrets.STAGE_API_KEY }}"/' /tmp/env-vars.json
          # fi
          
          echo "Applied stage environment variables"
        fi
        
        # Format for AWS Lambda environment variables
        jq -c '{"Variables": .}' /tmp/env-vars.json > /tmp/config.json

    # - name: Check if Lambda function exists
    #   id: check_lambda
    #   run: |
    #     if aws lambda get-function --function-name ${{ env.LAMBDA_FUNCTION_NAME }} 2>/dev/null; then
    #       echo "lambda_exists=true" >> $GITHUB_OUTPUT
    #     else
    #       echo "lambda_exists=false" >> $GITHUB_OUTPUT
    #     fi

    # - name: Create or Update Lambda function
    #   run: |
    #     if [ "${{ steps.check_lambda.outputs.lambda_exists }}" == "false" ]; then
    #       echo "Creating Lambda function..."
    #       aws lambda create-function --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
    #         --runtime python3.13 --role ${{ env.AWS_ROLE_TO_ASSUME }} \
    #         --handler ${{ env.HANDLER_FILE }}.${{ env.HANDLER_NAME }} --zip-file fileb:///tmp/function.zip \
    #         --environment "$(cat /tmp/config.json)"

    #       # Add permission for API Gateway to invoke the Lambda function
    #       STAGE_NAME=""
    #       if [ "${{ inputs.environment }}" == "stage" ]; then
    #         STAGE_NAME="v2"
    #       elif [ "${{ inputs.environment }}" == "prod" ]; then
    #         STAGE_NAME="v1"
    #       else
    #         STAGE_NAME="${{ inputs.environment }}"
    #       fi
          
    #       aws lambda add-permission \
    #         --function-name "${{ env.LAMBDA_FUNCTION_NAME }}" \
    #         --statement-id "AllowAPIGatewayInvoke" \
    #         --action "lambda:InvokeFunction" \
    #         --principal "apigateway.amazonaws.com" \
    #         --source-arn "arn:aws:execute-api:ca-central-1:125655559748:h8kq61julj/${STAGE_NAME}"
    #     else
    #       echo "Updating Lambda function code..."
    #       aws lambda update-function-code \
    #         --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
    #         --zip-file fileb:///tmp/function.zip --publish

    #       echo "Waiting for 10 seconds to allow AWS Lambda to process the code update..."
    #       sleep 10

    #       echo "Updating Lambda function configuration..."
    #       aws lambda update-function-configuration \
    #         --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
    #         --environment "$(cat /tmp/config.json)"
    #     fi

    - name: Clean up
      run: |
        rm -f /tmp/function.zip
        rm -f /tmp/config.json